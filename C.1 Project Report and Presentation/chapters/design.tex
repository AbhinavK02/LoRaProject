\section{Methodology and Design}
\label{sec: methodologyAndDesign}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Design Approach}
% \label{sec: designApproach}
% The design approach used in this project was a simple waterfall model. After a deliverable was completed, the next deliverable was started. This can be clearly seen in Figure \ref{fig: ganttChart}. The only exception to this model was during the Software Development and Project Implementation Deliverables (which are discussed in Section \ref{sec: implementation}) where some iterative testing and debugging was employed. The testing methods are discussed in Section \ref{sec: validationMethod}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{System Layer}
\label{sec: systemLayer}

\subsubsection{System Architecture}
\label{sec: systemArchitechture}
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{LoRa_FSD.png}
    \caption{Functional Structure Diagram of the System Architecture}
    \label{fig: fsd}
\end{figure}
\pagebreak

\subsubsection{Bill of Materials}
\label{sec: billOfMaterials}
This is an estimate of the materials required to make this project, these are all over estimates, as all components/materials except 2.1 - 2.6 were used from the university stock.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|l|p{2.8cm}|c|l|r|}
        \hline
        \textbf{Item} & \textbf{Part} & \textbf{Description} & \textbf{Qty} & \textbf{Notes} & \textbf{Total Price (€)} \\ \hline
        
        \rowcolor[gray]{0.9} \multicolumn{6}{|l|}{\textbf{1.0 Mechanical Components}} \\ \hline
        1.1 & Top Plate & Detection Plate & 1 & Wood (40x30x0.5cm) & 5.00 \\ \hline
        1.2 & Bottom Plate & Base for load cell & 1 & Wood (15x15x0.5cm) & 3.00 \\ \hline
        1.3 & M4 Screw & Top plate screw & 2 & - & 1.00 \\ \hline
        1.4 & M5 Hex Nut & Height spacer nut & 4 & - & 0.50 \\ \hline
        1.5 & M5 Screw & Bottom plate screw & 2 & - & 1.00 \\ \hline
        1.6 & M6 Hex Nut & Height spacer nut & 4 & - & 0.50 \\ \hline
        1.7 & Misc. & Tape, Glue & - & - & 0.50 \\ \hline
        
        \rowcolor[gray]{0.9} \multicolumn{6}{|l|}{\textbf{2.0 Electrical Components}} \\ \hline
        2.1 & Load Cell + HX711 & Load cell + Amplifier module & 1 & JOY-IT & 6.40 \\ \hline
        2.2 & Tilt Switch & Ball tilt switch & 1 & IDUINO & 0.94 \\ \hline
        2.3 & LDR & Light resistor & 1 & SERTRONICS & 1.35 \\ \hline
        2.4 & Battery & 1800 mAh Li-Ion & 1 & SOLDERED & 10.24 \\ \hline
        2.5 & MCU + LoRa & Xiao ESP32 + SX1262 & 1 & Seeedstudio & 11.68 \\ \hline
        2.6 & Antenna & Long range antenna & 1 & Amphenol-SAA & 2.69 \\ \hline
        2.7 & 1 kOhm resistor & Through Hole & 1 & YAGEO & 0.10 \\ \hline
        2.8 & 2 kOhm resistor & Through Hole & 1 & YAGEO & 0.10 \\ \hline
        2.9 & Wires & Jumper wires of different length & - & - & 0.30 \\ \hline
        2.10 & Misc. & Breadboard, Wire Sleeves, Solder & - & - & 0.50 \\ \hline
        \hline
        \multicolumn{5}{|r|}{Tax (VAT 20\%)} & 9.16 \\ \hline
        \multicolumn{5}{|r|}{\textbf{Grand Total (€)}} & \textbf{54.96} \\ \hline
        % for any changes check and adjust the BOM excel file
    \end{tabular}
    \caption{Combined Mechanical and Electrical Bill of Materials with Total Cost}
    \label{tab: bom}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hardware Layer}
\label{sec: HWLayer}
\subsubsection{Load Cell Assembly}
\label{sec: 3dDesign}
As understood from Section \ref{sec: loadCells}, to reliably detect any weight, the load cell must be allowed to bent as easily as possible. To prevent any mail from "missing" the detection platform, the platform must cover the entire box area. The design which allows this is shown in Figure \ref{fig: 3dModels}.

\begin{figure}[ht]
     \centering
     \begin{subfigure}{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{LoadCellArrangement.png}
         \caption{3D Model of Load Cell Arrangement}
         \label{fig: loadCellArrangement}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{Platform.png}
         \caption{Platform for mail detection}
         \label{fig: platform} 
     \end{subfigure}
     \caption{3D Model of detection platform}
     \label{fig: 3dModels}
\end{figure}
The height with the hex nuts, allow the load cell to have clearance to bend during load from the upper platform. The off center screw platform on both platform allow for best readings from the load cell. The size of the upper platform should match the post box size, however the lower platform allows for flexibility, it can be made just large enough to not cause toppling over and allow us to place necessary modules (such as the HX711). 

\bigskip

Some other design considerations include the requirement of the platform being rigid and lightweight, to allow load cell to be as sensitive as possible. A good material to use for the platform is wood. The screws should also be flat with the platform, to prevent mail from tearing / getting stuck. The process of assembling the load cell platform is shown in Figure \ref{fig: construction}.


\begin{figure}[ht]
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[height=4.5cm]{weight-sensor_construction-1.jpg}
        \caption{Construction of Lower Platform}
        \label{fig: lowerConstruction}                   
    \end{subfigure}
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[height=4.5cm]{weight-sensor_prototype-1.jpg}
        \caption{Load Cell Platform Prototype}
        \label{fig: constructionAssembled}                   
    \end{subfigure}
    \caption{Weight Sensor Construction}
    \label{fig: construction}
\end{figure}

The prototype shown in Figure \ref{fig: constructionAssembled} was then improved upon by increasing the size of the top platform to cover a greater area within the mailbox as well as adding a backboard to ensure mail does not slide off of the platform when the mailbox is opened. The final design is shown in Figure \ref{fig: finalProduct}.
% \subsubsection{Sensor Selection}
% \label{sec: sensorSelection}
% The sensors selected for this project were based on the functional requirements defined in Section \ref{sec: projectRequirements} as well as the shortcomings discussed in Section \ref{sec: literatureReview}. The general idea was to use multiple sensors to detect the same event, in order to increase reliability as well as a sensor which can detect not only events, but the current status of the mailbox. Hence, the light sensor and tilt sensor combination was chosen to detect the opening of the mailbox, while the load cell was chosen to detect the presence of mail. The reasons for choosing these specific sensors and their principle of operation are discussed in Section \ref{sec: sensors}.

\subsubsection{Schematic Design}
\label{sec: schematicDesign}
The complete schematic design of the system is shown in Figure \ref{fig: schematic}. The design is quite simple as the light and tilt sensors are digital sensors and connect directly to any GPIO pins on the microcontroller. The load cell on the other hand connects to the HX711 amplifier board, which then has a data line and clock line connecting to the ESP32-S3. The SX1262 LoRa module is connected via SPI, but the depiction in Figure \ref{fig: schematic} is a bit inaccurate. The kit comes with B2B connection which allows the MCU and LoRa module to be connected directly without any wiring. The pin mapping between the sensors and the microcontroller is shown in Table \ref{tab: pin-mapping}.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Sensor Pin} & \textbf{ESP32-S3 Pin} \\ \hline
        Tilt Sensor DO      & GPIO1  \\ \hline
        Battery Monitor     & GPIO2  \\ \hline
        Light Sensor DO     & GPIO3  \\ \hline
        HX711 CLK           & GPIO6  \\ \hline
        HX711 DAT           & GPIO43 \\ \hline
        SX1262 SCK          & GPIO7  \\ \hline
        SX1262 MISO         & GPIO8  \\ \hline
        SX1262 MOSI         & GPIO9  \\ \hline
    \end{tabular}
    \caption{Sensor-to-ESP32-S3 Pin Mapping}
    \label{tab: pin-mapping}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{LoRa_Sch_V2.png}
    \caption{Schematic Diagram of the System}
    \label{fig: schematic}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Embedded Software Layer}
\label{sec: ESWLayer}
\subsubsection{System Flow}
\label{sec: systemFlow}
The complete logical flow of the system is illustrated in \ref{fig: programmingFlowChart}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{system-flowchart_hor-transparent_v4.png}
    \caption{Programming Flow Chart of the Embedded Software}
    \label{fig: programmingFlowChart}
\end{figure}

The general idea is that upon start-up, the sensors are initialised, the LoRaWAN node is activated, the mail detection logic is executed to build the payload, the payload is transmitted and the controller is put to sleep. Once the light or tilt sensor is triggered, the ESP32-S3 wakes up and the process repeats. 

\bigskip

The actual execution of this flow is implemented in the \textbf{LR-V1.0.ino} as shown in Listing \ref{lst: mainCode}. All of the functions used are defined and explained in the subsequent sections.
\begin{lstlisting}[language=C++, caption={Main Code in LR-V1.0.ino}, label={lst: mainCode}]
#include "LoRaConfig.h"
#include "SensorManager.h"
// Start Here upon Wake-up
void setup() {
  Serial.begin(115200);

  // Initialising all the Sensors
  sensorManager_init();

  // Radio Setup
  Serial.println(F("\nSetup... "));

  ...

  // Activating the node for LoRaWAN
  state = lwActivate();
  Serial.println(F("Ready!\n")); // Ready to begin uploading

  // Reading Sensors and Building in Payload
  uplinkPayloadLen = detectMail(uplinkPayload);

  // Uploading the Payload
  state = lwUplink(uplinkPayload);

  delay(5000);

  // Sleep
  radio.sleep();
  goToSleep();
}
void loop() {
  // Empty since sleep interrupt operates as the loop
}
\end{lstlisting}


\subsubsection{Microcontroller Code Structure}
\label{sec: microcontrollerCodeStructure}

The microcontroller code was structured with modularity in mind and divided into four files: 
\begin{itemize}
    \item \textbf{SensorManager.cpp:} This file contains all the functions related to sensor initialization, reading sensor values, and processing the sensor data.
    \item \textbf{SensorManager.h:} This is the header file for SensorManager.cpp, containing function prototypes and necessary libraries and macros.
    \item \textbf{LoRaConfig.h:} This file handles the LoRaWAN communication, initializing required parameters, including libraries, defining functions for LoRa activation and upload.
    \item \textbf{LR-V1.0.ino:} This is the main file which essentially just runs the functions defined in the preceding files in the specific order required. 
\end{itemize}

To program the ESP32-S3, the Arduino IDE was used. The complete code can be found in the project repository (or in the attached zip file). Additionally, all libraries required are also included in the repository for ease of access. Simply click on File \textgreater{} Preferences and change the sketchbook location to the path of the project repository. The ESP32 board manager must also be installed following the instructions from \href{https://docs.espressif.com/projects/arduino-esp32/en/latest/installing.html}{Express-If Documentation}. Once installed, select "XIAO\_ESP32S3" from Tools \textgreater{} Board menu.

\subsubsection{Sensor Management}
\label{sec: sensorManager}
To initiliase the pins and parameters of the sensors, the \cmd{sensorManager_init()} function was defined as shown in Listing \ref{lst: sensorManagerInit} from the \textbf{SensorManager.h} file.

\begin{lstlisting}[language=C++, caption={sensorManager\_init() Function}, label={lst: sensorManagerInit}]
void sensorManager_init(){
  // Weight Sensor
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN); // initiliase weight sensor
  scale.set_scale(883.f);                           // Set the default (calibrated against scale)
  scale.power_down();                               // Put HX711 to sleep to save power
  delay(2000);
  SensorReading weightReading = readWeightSensor();
  weightState_prev = weightReading.value; // initial weight state

  // Light Sensor
  pinMode(LIGHT_SENSOR_PIN, INPUT); // Input mode for light sensor

  // Tilt Sensor
  pinMode(TILT_SENSOR_PIN, INPUT); // Input mode for tilt sensor

  // Setting up ADC for Battery Monitor
  analogReadResolution(12);       // 0 to 4095
  analogSetAttenuation(ADC_11db); // Allows full 0 to 3.3V range

  // End Intialisation
  Serial.println("Sensor Manager Initialized.");
}
\end{lstlisting}

Importantly, this function sets the scale factor for the load cell after calibration and configures the ADC for battery monitoring. The process of calibration is discussed in Section \ref{sec: weightSensorImplementation}. The ADC is set to 12-bit resolution to allow readings from 0 to 4095, and the attenuation is set to 11dB to allow the full voltage range of 0 to 3.3V to be read instead of the default 1.1V. The function also puts the HX711 load cell amplifier to sleep after initialization to save power.

\bigskip

Additionally, to keep the sensor readings organised, a struct called \cmd{SensorReading} was created. This struct contains the value read from the sensor as well as an identifying number. This is useful for logging and debugging purposes. The struct is defined in Listing \ref{lst: sensorReadingStruct} from the \textbf{SensorManager.h} file.

\begin{lstlisting}[language=C++, caption={sensorReading struct}, label={lst: sensorReadingStruct}]
struct SensorReading
{
    uint8_t id;    // Unique for each sensor ID
    uint8_t value; // The actual value
};
\end{lstlisting}

\subsubsection{Weight Sensor Implementation}
\label{sec: weightSensorImplementation}
To use the HX711 load cell amplifier, the HX711 library (V0.7.5) by Bogdan Necula was used. This library provides an easy to use interface for reading values from the load cell. 

\bigskip

Before using the load cell, it must be calibrated. This was done by weighing an object with a calibrated scale and then placing it on the load cell. The ESP32-S3 was programmed to tare the scale and then call the function \cmd{scale.get_units(10)} to get the average of 10 readings from the load cell. This value is then divided by the known weight to get the scale factor. After multiple iterations, a scale factor of 883.f was found to be accurate for this setup. This value was then set during initialization as shown in Listing \ref{lst: sensorManagerInit}. 

\bigskip

The actual reading of the weight sensor is done in the \cmd{readWeightSensor()} function defined in the \textbf{SensorManager.cpp} file. The function first wakes up the HX711 from sleep mode, reads the weight value and compares against predefined thresholds to determine if a light, medium, or heavy package is present. The most important line is  where the load cell value is read as shown in Listing \ref{lst: readWeightSensor}. The average of 10 values are taken and normalised by subtracting the tare value of 270 (the reading when no weight is present). This was done instead of the \cmd{scale.tare()} function from the HX711 library because running the tare function would require the user to ensure no weight is present either upon startup/wake-up or before every reading which is not feasible for this application. While this is certainly possible during initial installation and start up, every time the ESP32 wakes from deep sleep it would tare the load cell and thus ignore any mail which was placed while the device was asleep. 

\begin{lstlisting}[language=C++, caption={Excerpt ofreadWeightSensor() Function}, label={lst: readWeightSensor}]
SensorReading readWeightSensor() {
  scale.power_up(); // Wake HX711 from sleep
  ...

  if (scale.is_ready()) {
    weight = scale.get_units(10) - 270; // Normalised Average of 10 readings (based on calibration)
    ...
  } else {
    Serial.println("HX711 not found.");
  }

  reading.value = (uint8_t)weightState; // storing state value

  scale.power_down(); // Put HX711 to sleep to save power
  delay(500);
  return reading;
}
\end{lstlisting}

\subsubsection{Battery Monitor Implementation}
A battery monitor was implemented using the \cmd{batteryMonitor()} function defined in the \textbf{SensorManager.cpp} file and shown in Listing \ref{lst: batteryMonitor}. From Figure  \ref{fig: schematic}, we can see a voltage divider is used because the maximum battery voltage of 4.2V, which exceeds the maximum input voltage of the ESP32-S3 (3.3V). This is compensated for in the code by the multiplication of the \cmd{adcVoltage} by the voltage divider ratio, which in this case is 1.5. The function then maps the voltage linearly to a percentage based on the operating voltage range of 3.1V (0\%) to 4.2V (100\%) to give the user an easily readable indication of the battery level. 

\begin{lstlisting}[language=C++, caption={batteryMonitor() Function}, label={lst: batteryMonitor}]
SensorReading batteryMonitor() {
  SensorReading reading;
  uint8_t batPercentage;
  reading.id = ID_BAT_MONITOR;
  int adcValue = analogRead(BAT_MONITOR_PIN);
  float adcVoltage = (adcValue * 3.3) / 4095; // Calculating U[V] at the pin
  float batVoltage = adcVoltage * 1.5; // Using ratio to find actual U[V]
  if (batVoltage >= 4.20) { //4.20V ^= 100%
    reading.value = 100;
  } else if (batVoltage <= 3.10) { //3.10V ^= 0%
    reading.value = 0;
  } else { // Mapping to percentage
    batPercentage = (batVoltage - 3.10) * 100 / (1.1); 
    reading.value = batPercentage;
  }
  return reading;
}
\end{lstlisting}

\subsubsection{Mail Detection logic}
\label{sec: mailDetectionLogic}
With all the sensors setup, detecting the state of the mailbox is handled by the \cmd{detectMail()} function found in \textbf{SensorManager.cpp}. The function first reads the weight sensor to determine if there is mail present, then checks for tampering by comparing the current weight state with the previous one. If no change is detected, it indicates that the lid was opened, but no mail was added or removed which by our logic means someone is looking into the mailbox for potentially nefarious reasons. If a change is detected, the function encodes the type of mail detected based on the weight state from the \cmd{readWeightSensor()} function. The function's argument is a pointer to a payload buffer where the encoded data is stored for transmission via LoRaWAN. Thus the actual encoding process is as simple as adding the relevant information into the buffer with a line like \cmd{payloadBuffer[len++] = ID;}. 

\bigskip

One significant feature of this function is a 25 second delay implemented before the weight sensor is read to ensure the mail person has sufficient time to place all the mail onto the platform. This was added after testing showed that the load cell could miss mail events if not placed quickly enough as discussed in Section \ref{sec: emailNotificationResults}. 

% \begin{lstlisting}[language=C++, caption={detectMail() Function}, label={lst: detectMail}]
% uint16_t detectMail(uint8_t *payloadBuffer) {
%   uint16_t len = 0;
%   payloadBuffer[len++] = ID_DEVICE;                 // Device ID
%   delay(25000);                                     // Wait for mail to be placed
%   SensorReading weightReading = readWeightSensor(); // read the weight sensor value
%   SensorReading batteryReading = batteryMonitor();  // read the battery voltage
%   weightState_curr = weightReading.value;           // Set current state from reading
%   if (weightState_curr == weightState_prev) { // if no change, then someone is peaking
%     Serial.println("Tampering Detecting");
%     payloadBuffer[len++] = ID_TAMPERING; // Encode Tampering code
%   } else { // If state changed, look at the mail status
%     Serial.print("Mail was ");
%     Serial.println(weightState_curr > weightState_prev ? "Added" : "Removed"); // Mail is there?
%     switch (weightState_curr) {
%         case 3:
%             payloadBuffer[len++] = ID_HEAVY_MAIL;
%             break;
%         case 2:
%             payloadBuffer[len++] = ID_MEDIUM_MAIL;
%             break;
%         case 1:
%             payloadBuffer[len++] = ID_LIGHT_MAIL;
%             break;
%         case 0:
%             payloadBuffer[len++] = ID_NO_MAIL;
%             break;
%     }
%   }
%   // Also add the battery voltage into the payload
%   payloadBuffer[len++] = batteryReading.id;
%   payloadBuffer[len++] = batteryReading.value;
%   weightState_prev = weightState_curr; // update weight state
%   Serial.println();
%   return len;
% }
% \end{lstlisting}

\subsubsection{Wake-up and Sleep Logic}
In an effort to save as much power as possible, the ESP32-S3 is put into sleep mode after each mail detection session and transmission. This is done using the function \cmd{goToSleep()} defined in \textbf{SensorManager.cpp} and shown in Listing \ref{lst: goToSleep}. This function configures the wake-up sources to be the light sensor and tilt sensor pins, such that when either of these pins goes low (indicating the mailbox lid is opened or light is detected inside the mailbox), the ESP32 will wake up from deep sleep. 
\begin{lstlisting}[language=C++, caption={goToSleep() Function}, label={lst: gotToSleep}]
void goToSleep() {
  Serial.println("Going to deep sleep...");

  // Configure Wake Interrupt
  esp_sleep_enable_ext1_wakeup((1ULL << LIGHT_SENSOR_PIN) | (1ULL << TILT_SENSOR_PIN), ESP_EXT1_WAKEUP_ANY_LOW);

  // Sleep
  Serial.flush();
  esp_deep_sleep_start();
}
\end{lstlisting}

\subsubsection{LoRaWAN Configuration}
\label{sec: loraConfig}
All of the configuration and functions required for LoRaWAN communication are defined in the \textbf{LoRaConfig.h} file. The libraries required are RadioLib (V7.4.0) by Jan Gromes and Preferences (installed in Arduino IDE by default).

\bigskip

The first and most important step is defining the access keys for The Things Network (TTN). Setting up a device on TTN is discussed in Section \ref{sec: ttnConfiguration}, but once the device is created, the keys can be found in the console. These keys were first defined as macros for easy access and then copied into variables for use as shown in Listing \ref{lst: ttnKeys}.

\begin{minipage}{\textwidth}
    \begin{lstlisting}[language=C++, caption={TTN Key Definition}, label={lst: ttnKeys}][float]
    // TTN Keys for Accessing the Network
    #ifndef RADIOLIB_LORAWAN_JOIN_EUI // All zeros for TTN compliance
    #define RADIOLIB_LORAWAN_JOIN_EUI 0x0000000000000000
    #endif

    #ifndef RADIOLIB_LORAWAN_DEV_EUI
    #define RADIOLIB_LORAWAN_DEV_EUI 0x070B3D57ED0074D0
    #endif

    #ifndef RADIOLIB_LORAWAN_APP_KEY
    #define RADIOLIB_LORAWAN_APP_KEY 0x02, 0xBC, 0xE7, 0xC1, 0x02, 0xB3, 0x18, 0xD7, 0x02, 0xF2, 0x18, 0xDF, 0x9E, 0x45, 0xD1, 0x8E
    #endif

    ...

    // Copy over Keys
    uint64_t joinEUI = RADIOLIB_LORAWAN_JOIN_EUI;
    uint64_t devEUI = RADIOLIB_LORAWAN_DEV_EUI;
    uint8_t appKey[] = {RADIOLIB_LORAWAN_APP_KEY};
    \end{lstlisting}
\end{minipage}

After the keys are set, the LoRa node is activated using the function \cmd{lwActivate()} found in the \textbf{LoRaConfig.h} file. The Over the Air Activation (OTAA) method is used instead of the Activation By Personalization (ABP) method for better security and flexibility. This is done using the RadioLib command \cmd{node.activateOTAA()} as shown in Listing \ref{lst: ttnJoinFresh}. Because this process sometimes fails due to network issues or recognition issues on the TTN side, a loop is implemented to retry joining until successful.

\begin{lstlisting}[language=C++, caption={TTN Joining Loop in lwActivate()}, label={lst: ttnJoinFresh}]
while (state != RADIOLIB_LORAWAN_NEW_SESSION) {
    Serial.println(F("Joining LoRaWAN fresh..."));
    state = node.activateOTAA();

    // Storing Nonces
    uint8_t *persist = node.getBufferNonces();
    memcpy(lwNonces, persist, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
    store.putBytes("nonces", lwNonces, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);

    if (state == RADIOLIB_LORAWAN_NEW_SESSION)
        break;

    // Fail and Retry
    Serial.print(F("Join failed: "));
    Serial.println(state);
    delay(5000); // Retry every 5s
}
Serial.println(F("Join successful"));
\end{lstlisting}

To make re-joining faster on subsequent wake-ups and power cycles, the nonces are stored in the ESP32's non-volatile memory (NVM) using the Preferences library as shown in Listing \ref{lst: ttnJoinFresh}. Once the nonces are restored, the node attempts to re-join in a loop until successful, after which the new nonces are stored. This solved the major rejoining issue discussed in Section \ref{sec: ttnRejoinIssue}. Additionally, the session is also stored in the RTC memory allowing for even faster re-joining after deep sleep wake-ups. This is done because storing sessions indefinitely within the NVM may lead to unnecessary wear on the memory. This re-joining process is shown in Listing \ref{lst: ttnReJoin}. Notice that the program checks if restoring the session is possible first before looping through the nonces.

\begin{minipage}{\textwidth}
    \begin{lstlisting}[language=C++, caption={TTN Re-Joining Loop using Stored Nonces or Session in TTN Joining Loop in lwActivate()}, label={lst: ttnReJoin}]
    // Restore nonces from NVM
    store.getBytes("nonces", lwNonces, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
    state = node.setBufferNonces(lwNonces);
    debug(state != RADIOLIB_ERR_NONE, F("Restoring nonces failed"), state, false);

    // Restore session from RTC
    state = node.setBufferSession(lwSession);

    // Joining TTN (if restore not immediate)
    while (state != RADIOLIB_LORAWAN_NEW_SESSION) {
        Serial.println(F("Joining LoRaWAN..."));
        state = node.activateOTAA();
        if (state == RADIOLIB_LORAWAN_SESSION_RESTORED) {
            Serial.println(F("LoRaWAN session restored"));
            break;
        } else if (state == RADIOLIB_LORAWAN_NEW_SESSION) {
            Serial.println(F("Join successful, saving nonces"));
            uint8_t *persist = node.getBufferNonces();
            Serial.print("Dev Nonces: ");
            Serial.println((char *)persist);
            memcpy(lwNonces, persist, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
            store.putBytes("nonces", lwNonces, RADIOLIB_LORAWAN_NONCES_BUF_SIZE);
            break;
        }
        Serial.print(F("Join failed: "));
        Serial.println(state);
        delay(5000); // Retry every 5s
    }
    \end{lstlisting}
\end{minipage}
\subsubsection{LoRaWAN Data Transmission}
The actual transmission of data via LoRaWAN is handled by the \cmd{lwUplink()} function defined in the \textbf{LoRaConfig.h} file. This function transmits the payload encoded in the \cmd{detectMail()} function using the RadioLib command \cmd{node.sendReceive(uplinkPayload, uplinkPayloadLen)}. Similar to in the joining process in in Listing \ref{lst: ttnJoinFresh}, the function loops to until the data is successfully sent. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transport Layer}
\label{sec: transportLayer}
\subsubsection{TTN Configuration}   
\label{sec: ttnConfiguration}
To set up the device on The Things Network (TTN), first an account was created on \href{https://www.thethingsnetwork.org/}{The Things Network}. After logging in, a new application and end-device were created. The end-device was configured with a Join EUI of all zeros to comply with TTN's non-commercial regulations and the Europe 868.1 MHz frequency plan since the device is being developed in Germany. Most importantly, the LoRaWAN specification was set to 1.0.4 as it is the most up-to-date and RadioLib V7.4.0 is designed to comply with the specifications. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Application Layer}

This section covers the implementation of the backend server and application layer, which is responsible for receiving data from The Things Network, decoding the payload, storing the data, and providing a user interface for monitoring the mailbox status.
The link with the The Things Network is done using webhooks, which send HTTP POST requests to the python server whenever new data is received from the LoRaWAN device.

\subsubsection{Backend Server Setup}
\label{sec: initalSetup}
To set up the backend server, we require three files, which include: 'server.py', '.env', and 'requirements.txt'. Each file servers a specific purpose:
\begin{itemize}
    \item \textbf{server.py:} This is the main server file that contains the Flask application code. It handles incoming requests, decodes the payload, updates the mailbox status, and serves the user interface.
    \item \textbf{.env:} This file contains environment variables such as server port, authentication token, email sender credentials, and recipient email addresses. This allows for easy configuration without hardcoding sensitive information in the code.
    \item \textbf{requirements.txt:} This file lists all the Python libraries required to run the server. 
\end{itemize}
These all need to be placed in the same directory for the server to function correctly. The server can then be started by running the command `python server.py` in the terminal.
The dependencies, to be added to requirements.txt as shown in Listing \ref{lst: requirementstxt}, can be installed using the command `pip install -r requirements.txt`.
\begin{lstlisting}[caption={requirements.txt file contents}, label={lst: requirementstxt}]
Flask==2.3.3
python-dotenv==1.0.0
\end{lstlisting}
These can be installed directly using pip as well, however using requirements.txt makes it easier and more future proof. These steps can be also be avoided, and the bash script from Section \ref{sec: issuesWithStaticIPAndHosting} be used directly to install the required
libraries if they are missing.

\smallskip

Next a random authentication token must be generated, for Windows 11, the command shown in Listing \ref{lst: generateAuthToken} can be used.
\begin{lstlisting}[language=bash, caption={Generate random auth token command}, label={lst: generateAuthToken}]
$bytes = New-Object byte[] 16; (New-Object System.Security.Cryptography.RNGCryptoServiceProvider).GetBytes($bytes);
[System.BitConverter]::ToString($bytes) -replace '-'
\end{lstlisting}

Now you can open the .env file using a text editor of your choice (here edit by MS was used). The following variables must be
added as shown in Listing \ref{lst: envFileContents}:
\begin{lstlisting}[caption={.env file contents}, label={lst: envFileContents}]
export SERVER_PORT=3000
export AUTH_TOKEN=<token from above>

EMAIL_SENDER=your_email@gmail.com
EMAIL_PASSWORD=your_app_password_here
\end{lstlisting}

The main contents of server.py are explained in the following sections and full code can be found in the project repository. 

\subsubsection{Payload Decoder}
\label{sec: payloadDecoder}
The LoRaWAN is able to send the bits to The Things Network. However for these to be actually useful to the user they must be 
decoded and used to represent relevant information for a user, this includes the mail status, the battery and which post box it is. For this first a payload decoder must be made. This is made keeping in mind how bits were encoded in the first place. The decoder can be seen in Listing \ref{lst: payloadDecoder}
\begin{lstlisting}[language=Python, caption={Payload Decoder Function}, label={lst: payloadDecoder}]
def decode_mailbox_data(base64_string):
    try:
        raw_bytes = base64.b64decode(base64_string)
        if len(raw_bytes) < 4:
            return None, "Error: Short Data", "red", None

        # 1. Decode ID (Hex to Int logic)
        try:
            device_id = int(f"{raw_bytes[0]:x}") 
        except:
            device_id = raw_bytes[0]

        state_byte = raw_bytes[1]
        value_id = raw_bytes[2]
        val = raw_bytes[3]

        # 2. Decode Status (Aligned with new JS Decoder)
        if state_byte == 0x04:
            status, color = "Tampering Alert", "red"
        elif state_byte == 0x05:
            status, color = "Heavy Mail", "#004d40" 
        elif state_byte == 0x06:
            status, color = "Medium Mail", "#00897b" 
        elif state_byte == 0x07:
            status, color = "Light Mail", "#4db6ac" 
        elif state_byte == 0x08:
            status, color = "No Mail", "blue"
        else:
            status, color = f"Unknown: {hex(state_byte)}", "orange"

        # 3. Decode Battery (valueID 0x09)
        battery = val if value_id == 0x09 else None

        return device_id, status, color, battery
            
    except Exception as e:
        logger.error(f"Decoding error: {e}")
        return None, "Decoding Failed", "black", None
\end{lstlisting}
This allows us to correctly identify if a heavy, medium or light package was detected. This information can then be used to update the website to represent the appropriate information and also be included in the mail sent to the user.

The key parts of the decoder are explained below:
\begin{itemize}
    \item "state\_byte" is used to determine the mail status, this is done by checking the value of the byte and mapping it to the appropriate status message.
    \item There is return at the start for robustness, in case the payload is too short or empty. 
    \item "value\_id" has been used as a form of future proofing, in case more values are added to the payload in the future.
\end{itemize}
For actual mapping of device ID to device name and email addresses, a dictionary is used as shown in Listing \ref{lst: deviceMapping}.
\begin{lstlisting}[language=Python, caption={Device mapping method}, label={lst: deviceMapping}]
    # --- Device Mapping ---
    DEVICE_NAMES = {
        33: "PostBox SAN" 
    }
    # --- Email Mapping ---
    DEVICE_RECIPIENTS = {
        33: "email1@gmail.com, email2@gmail.com"
    }
\end{lstlisting}
More can be added as just new rows with the similar syntax just a comma at the end of all rows except the last one. 
Multiple email addresses can also be added by separating them with a comma within the double quotes.\\

\subsubsection{Frontend Implementation}
\label{sec: frontendImplementation}
For the actual server, which the user interacts, with a python server was created. This server uses the Flask framework to create a simple web application that displays the status of the mailbox. 
The server listens for incoming data from The Things Network and updates the mailbox status accordingly. The relevant code snippet is shown in Listing \ref{lst: flaskServer}
\begin{lstlisting}[caption={Flask Server Code Snippet}, label={lst: flaskServer}]
@app.route('/', methods=['GET'])
def show_dashboard():
    d = dashboard_data
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Mailbox Monitor</title>
        <meta http-equiv="refresh" content="5">
        <style>
            body {  
                font-family: 'Segoe UI', sans-serif; 
                text-align: center; 
                padding: 40px; 
                background-color: #f0f2f5; }
            .card { 
                background: white; 
                padding: 40px; 
                border-radius: 15px; 
                display: inline-block; 
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);                     
                width: 450px; }
            .status-box {   
                font-size: 32px;                         
                font-weight: bold; 
                margin: 20px 0; 
                padding: 20px; 
                color: white; 
                border-radius: 10px; 
                background-color: {{ d.status_color }}; }
            .battery-indicator { 
                font-weight: bold; 
                font-size: 18px; 
                padding: 5px 15px; 
                border-radius: 20px; 
                display: inline-block; 
                color: white; 
                background-color: {{ d.battery_color }}; }
            .meta { 
                color: #888; 
                font-size: 13px; 
                margin-top: 15px; }
            table { 
                width: 100%; 
                border-collapse: 
                collapse; 
                margin-top: 20px; 
                text-align: left; }
            th, td { 
                padding: 10px; 
                border-bottom: 1px 
                solid #eee; 
                font-size: 14px; }
            .dot { 
                height: 10px; 
                width: 10px; 
                border-radius: 50%; 
                display: inline-block; 
                margin-right: 5px; }
        </style>
    </head>
    <body>
        <div class="card">
            <h1>Smart Mailbox</h1>
            <h2 style="color:#666">{{ d.device_name }}</h2> 
            <div class="status-box">{{ d.status_text }}</div>
            <div class="battery-indicator">{{ d.battery_level }}</div>
            <p class="meta">Last Update: {{ d.timestamp }}</p>
            <h3>Recent Activity</h3>
            <table>
                <tr><th>Time</th><th>Event</th><th>Bat</th></tr>
                {% for event in d.history %}
                <tr>
                    <td>{{ event.time }}</td> 
                    <td>
                        <span class="dot" 
                            style="background-color: {{ event.color }};">
                        </span>{{ event.status }}</td>
                    <td>{{ event.battery }}</td>
                </tr>
                {% endfor %}
            </table>
        </div>
    </body>
    </html>
    """
    return render_template_string(html, d=d)
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validation Methods}
\label{sec: validationMethods}
During the development of the system, it became essential to validate system at different stages. Components were tested against the requirements outlined in Sections \ref{sec: functionalRequirements} and \ref{sec: technicalRequirements}. 

% \bigskip

The following briefly describes the validation methods used for the main requirements:
\begin{itemize}
\item \textbf{Mail Detection:} Various objects ranging from around 20\,g to above 100\,g were weighed on a scale and then placed on the load cell platform to check if the load cell could detect the presence of mail and classify them accurately. 10 different objects were used for testing including letters, pieces of cardboard, and power bank. The setup for this test is shown in Figure \ref{fig: mailDetectionTest}.
%     \item \textbf{Lid Opening Detection:} The tilt switch and LDR were tested by opening and closing the mailbox lid multiple times. Using the serial monitor, the readings from both sensors were observed to ensure they accurately detected the lid status.
%     \item \textbf{LoRa Communication:} The LoRa module was tested by sending test messages from the microcontroller to the LoRaWAN gateway. The successful receipt of messages was confirmed via TTN console and Datacake dashboard.
\item \textbf{Email Notification:} The email notification system was tested by simulating mail detection events and verifying that the mail was detected and emails were sent to the designated recipient. This was tested with the system installed in the mailbox as shown in Figure \ref{fig: finalProduct}. The test was conducted with 3 different objects. For each object, placing inside, removing and opening the lid without placement were tested.
%     \item \textbf{Battery Status Monitoring:} The battery monitor was tested by simulating mail detection events and checking the battery level readings on the dashboard and then checking them against a multimeter.
\item \textbf{Battery Life:} The system was powered by the battery and current consumption was monitored while idle and while sending messages. The readings were used to estimate the battery life. The experimental setup for this test is shown in Figure \ref{fig: currentConsumptionTest}.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{weight-sensor_prototype-2.jpg}
    \caption{Experimental Setup for Mail Detection Testing Using Various Objects of Different Weights.}
    \label{fig: mailDetectionTest}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{current-consumption-setup.jpg}
    \caption{Experimental Setup for Battery Life Estimation by Measuring Current Consumption.}
    \label{fig: currentConsumptionTest}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%